<details>
<summary>은지</summary>
# 1. JSX란?

- 페이스북이 임의로 만든 새로운 문법
- 트랜스파일러를 거쳐 자바스크립트 런타임이 이해할 수 있는 의미 있는 자바스크립트 코드로 변환해야 한다
- XML 스타일의 트리 구문을 작성하는 데 도움을 주는 문법이다

## JSX의 정의

- `JSXElement`, `JSXAttributes`, `JSXChildren`, `JSXString` 4가지 컴포넌트를 기반으로 구성돼 있다
- `JSXElement` : HTML 요소와 비슷한 역할을 한다
- `JSXAttributes` : `JSXElement` 에 부여할 수 있는 속성, 필수값 아니다
- `JSXChildren` : `JSXElement` 의 자식 값을 나타낸다
- `JSXString` : JSX 문법을 사용하여 작성된 문자열이다

---

# 2. 가상 DOM과 리액트 파이버

## 가상 DOM의 탄생 배경

- 웹 페이지를 렌더링 하는 과정은 매우 복잡, 비용이 많이 든다
- 인터렉션을 통해 다양한 정보도 노출된다
- DOM을 관리하는 과정에서 부담해야 할 비용이 커진다
- 따라서, 가상 DOM은 실제 DOM의 잦은 조작으로 인한 성능 문제를 해결하기 위해 등장했다
- 가상 DOM은 웹 페이지가 표시해야 할 DOM을 일단 메모리에 저장하고 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영한다

## 가상 DOM을 위한 아키텍처, 리액트 파이버

- 가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이다
- 리액트에서 관리하는 평범한 자바스크립트 객체이다.
- 파이버는 파이버 재조정자(fiiber reconciler)가 관리한다
- DOM을 비교해 변경 사항을 수집하여, 둘 사이에 차이가 있으면 관련 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다. → 재조정 알고리즘

### 리액트 파이버 목표

- 리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하는 것이다
- 하는 일
    - 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다
    - 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다
    - 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다
- 이 과정이 비동기로 일어난다

### 파이버 구현

- 파이버는 하나의 작업 단위로 구성되어 있다.
- 작업 단위를 하나씩 처리하고 `finishedWork()` 라는 작업으로 마무리한다. 그리고 이 작업 사항을 커밋해 실제 브라우저 DOM에 가시적인 변경사항을 만들어 낸다.
1. 랜더 단계에서 리액트는 리액트 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
2. 커밋 단계에서는 DOM에 실제 변경 사항을 반영하기 위한 작업인 `commitWork()` 가 실행되는데, 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.
- 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나, DOM의 변경이 필요한 시점 등에 실행된다
- 리액트가 파이버를 처리할 때마다 이런 작업을 직접 처리 혹은 스케줄링 하기도 한다

### 리액트 파이버 트리

- 더블 버퍼링을 사용한다
    - 현재 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 workInProgress 트리
    - 리액트 파이버의 작업이 끝나면 리액트는 단순히 포인터만 변경해 workInProgress트리를 현재 트리로 바꾼다
- 커밋단계에서 수행

### 파이버의 작업 순서

1. `beginWork()` 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다
2. 작업이 끝나면 그 다음 completeWork() 함수를 실행해 파이버 작업을 완료한다
3. 형제가 있다면 형제로 넘어간다
4. 2번, 3번 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음

setState로 인한 업데이트 요청이 생기면 workInProgress트리를 다시 빌드하고 파이버가 이미 존재하니깐 되도록 새로 생성하지 않고 기존 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다

### 파이버와 가상 DOM

즉, 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이고 비동기로 이뤄진다. 

DOM에 반영하는 것은 동기적으로 일어나야 하고 메모리 상에서 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.

---

# 클래스형 컴포넌트와 함수형 컴포넌트

## 클래스형 컴포넌트

### 클래스형 컴포넌트의 생명주기 메서드

- 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

**`render()`**

컴포넌트가 UI를 렌더링하기 위해 쓰인다. 마운트와 업데이트 과정에서 일어난다

주의할 것은 항상 순수해야 하며 부수효과가 없어야 한다. 즉, 같은 입력값(props or state)이 들어가면 항상 같은 결과물을 반환해야 한다.

**`componentDidMount()`**

컴포넌트가 마운트되고 준비가 되면 그 다음으로 호출하는 메서드이다.

**`componentDidUpdate()`**

컴포넌트 업데이트가 일어난 이후 바로 실행된다

**`componentWillUnmount()`**

컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.

메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치이다.

**`shouldComponentUpdate()`**

state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용한다.

**`static** **getDerivedStateFromProps()**`

render()를 호출하기 직전에 호출된다.

반환되는 객체는 해당 객체의 내용이 모두 state로 들어가게 된다.

**`getSnapShotBeforeUpdate()`**

DOM이 업데이트되기 직전에 호출된다. 

DOM에 렌더링되기 전에 윈도우 크기 조절, 스크롤 위치 조정 등 작업 처리에 유용하다.

**`getDerivedStateFromError()`**

자식 컴포넌트에 에러 상황에 발생했을 때 호출되는 에러 메서드이다.

**`componentDidCatch()`**

자식 컴포넌트에서 에러가 발생했을 때 실행된다 `getDerivedStateFromError` ****에서 에러를 잡고 state를 결정한 이후에 실행된다.

`ErrorBoundary` 를 만들기 위한 목적으로 많이 사용된다

### 클래스 컴포넌의 한계

- 데이터의 흐름을 추적하기 어렵다
- 애플리케이션 내부 로직의 재사용이 얼벼다
- 기능이 많아질수록 컴포넌트 크기가 커진다
- 클래스는 함수에 비해 상대적으로 어렵다
- 코드 크기를 최적화 하기 어렵다
- 최종 결과물인 번들 크기 줄이는 것이 어렵다
- 핫 리로딩을 하는데 상대적으로 불리하다 (핫 리로딩 : 변경 사항이 발생했을 때 앱을 다시 시작하지 않고서도 해당 변경된 코드만 업데이트해 변경 사항을 빠르게 적용하는 기법)

## 함수형 컴포넌트 vs 클래스형 컴포넌트

- 생명주기의 부재
- 함수형 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. 반면 클래스형 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다
</details>